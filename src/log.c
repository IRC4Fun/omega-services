/*
 *                OMEGA IRC SECURITY SERVICES
 *                  (C) 2008-2012 Omega Dev Team
 *
 *   See file AUTHORS in IRC package for additional names of
 *   the programmers.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 1, or (at your option)
 *   any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *
 *    $Id: log.c 2252M 2013-08-09 20:57:45Z (local) $
 */


#include "stdinc.h"
#include "server.h"

char *LogType[] = {
	"Info",     //0
	"Debug",    //1
	"Debug 2",  //2
	"Error",    //3
	"Critical", //4
	"Event",    //5
	"Link",     //6
	"LogUser",  //7
	"LogChan",  //8
	"LogIO",    //9
	"Module",   //10
	"Debug 3",   //11
	"Backtrace", //12
	"Socket",
	0
};

static unsigned long curday = 0;

/*************************************************/
/**
  * Init Function - Called when server starts.
  */



/*************************************************/
void open_log (void)
{
    char    LogName[1024];
    char    timestamp[32];

    time_t      t;
    struct tm   *tmp;

    time (&t);
    tmp = localtime (&t);

    if (logfd > 0)
    {
        if (tmp->tm_mday == curday)
            return;
        else
            fclose (logfd);
    }

    snprintf (LogName, sizeof(LogName), "%s%s%s_%d%d%d",
            DPATH, LPATH, (CfgSettings.network[0])? CfgSettings.network : "security",
            (tmp->tm_year + 1900), (tmp->tm_mon + 1), tmp->tm_mday);

    curday  = tmp->tm_mday;

    logfd   = fopen (LogName, "a");

    if (!logfd)
        fprintf (stderr, "Warning: Could not open logfile (%s): %s\n", LogName, strerror(errno));
   // else 
//	 fprintf(stderr, "Opened log file: %s\n", LogName);

    return;
}
/*************************************************/

void close_logs	(void)
{

	if (logfd)
	{
		fflush(logfd);
		fclose(logfd);
	}
	return;
}


/*************************************************/
/**
 * alog - Checks to see if a log is open, then writes 
 * to the log file, also if we are in debug it will
 * print the line to the console.  
 *
 *  @param TYPE (int) Log type
 *          - LOG_INFO   0  - Default/Basic log line 
 *          - LOG_DEBUG  1  - Debug information (Only logged if debug is higher then 1)  
 *          - LOG_DEBUG2 2
 *          - LOG_ERROR  3  - Error
 *          - LOG_FATAL  4  - Critical/Fatal Error
 *          - LOG_EVENT  5  - Event related log (Generated by eventengine.c)
 *          - LOG_LINK   6  - IRCd Link related (Not normally used) 
 *          - LOG_USER   7  - User related logging (Used by the core to log quit/connect)
 *          - LOG_CHAN   8  - Channel related logging (Not normally used)
 *          - LOG_IO     9  - Raw Input out put logging (Please do not use CORE/SOCKETENGINE only)
 *          - LOG_MODULE 10 - Module LOAD/UNLOAD/Error 
 *          - LOG_SOCKET 11 - Socketengine logging
 *          - LOG_BACKTRACE 12 - Used if backtrace is enabled
 *          - LOG_DEBUG3 13 - Socket debug level logging
 *  @param fmt (char*) Format string for variable arguments
 *  @param ... (mixed) Variable arguments. 
 *
 *  XXX- Use constants as opposed to numeric values - this will prevent
 *       bad logging in the future.
 */
 

void alog(int TYPE, char *fmt, ...)
{

    if (strlen(fmt) > 4096)
		return; //bail its WAY to big 

    char logstr[4096]; /* Increase this so we can log full packets */
    va_list	args;

    open_log ();

	memset(logstr, '\0', sizeof(logstr));

	//check for bad fd
    if (!logfd)
        return;

	va_start(args,fmt);
	vsnprintf(logstr,sizeof(logstr),fmt,args);

	switch (TYPE)
	{
            case  DEBUG:
                    if (!debug)
                            return;
                    break;
            case DEBUG_2:
                    if (debug < 2)
                            return;
                    break;
            case DEBUG3:
                    if (debug < 3)
                            return;
                    break;

	}
	if ((nofork && debug) || (TYPE == LOG_FATAL))
            printf("[%s] %s\n",LogType[TYPE], logstr);

    fprintf(logfd,"[%lu] %s\n",ServerTime,logstr);
    fflush(logfd);
	va_end(args);
	return;
}

/***********************************/

void close_log(void)
{
    if (logfd)
	    fclose (logfd);
}

/***********************************/
void sendto_logchan (char *fmt, ...)
{
    va_list     args;
    char        tmp[1024];

    if ((uselogchan != 1) || (sync_state != RUNNING))
		return;

    va_start (args, fmt);
    vsnprintf (tmp, 1024, fmt, args);
    va_end (args);

    if (!s_Guardian)
        return;

    if ((sync_state == 3) && logchan && (!IRCd.p10))
	    send_line (":%s PRIVMSG %s :%s", (IRCd.ts6)? s_Guardian->uid : s_Guardian->nick, logchan, tmp);
    else if ((sync_state == 3) && logchan && IRCd.p10)
        send_line ("%s P %s :%s", s_Guardian->uid, logchan, tmp);

    return;
}


/************************************/

void sendto_console(char *fmt, ...)
{
     va_list     args;
     char        tmp[1025];

     va_start (args, fmt);
     vsnprintf (tmp, 1024, fmt, args);

     fprintf(stderr,"%s\r\n", tmp);

    va_end(args);
    return;

}

/************************************************/
 /**
 *  Log - This function logs to our log file, as
 *        well as sends to logchan... This doesn't
 *        do any implicit checks, and will rely on
 *        the user to know what he/she is doing.
 *
 *  @param TYPE - The log level/type
 *  @param fmt  - Formatted VA_ARG strings, or
 *                standard parameters.
 *  @return void
 */


void Log(char *fmt, ...)
{
     va_list     args;

     char tmp[1024];

     va_start (args, fmt);
     vsnprintf (tmp, 1024, fmt, args);

    sendto_logchan(tmp); //send to our logchan

    alog(0,tmp);      //then alog


    va_end(args);
    return;

}

/************************************/

